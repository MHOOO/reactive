<div class="lift:surround?with=default;at=content">

<h2>Fundamentals</h2>

<h3><code>DOMEvent</code></h3>
<p>Perhaps the best way to start explaining reactive-web at the
higher level is by introducing <code>DOMEvent</code>. <code>DOMEvent</code>
is a simple trait that represents an event raised by the browser. It has
case classes and case objects derived from it that represent the various
DOM events and their state. When the browser fires an event, <code>reactive-web</code>
may fire a corresponding DOMEvent instance to your code.</p>

<h3><code>DOMEventSource</code></h3>
<p>Now that we know about that, let's move on to <code>DOMEventSource</code>.
<code>DOMEventSource</code> wraps an <code>EventStream</code> that fires
<code>DOMEvent</code> instances. Let's go through a few of its members:</p>
<dl>
	<dt><code>rawEventData</code></dt>
	<dd>A <code>Map[String,JsExp]</code> of extra data to send in the
	ajax request when the browser fires the event. The <code>JsExp</code>
	values are JavaScript expressions that will be evaluated when the event
	fires and stored under the specified key.</dd>
	<dt><code>rawEventStream</code></dt>
	<dd>This <code>EventStream</code> fires the raw data from the ajax
	request. Each event has the type <code>Map[String,String]</code>, where
	keys are taken from <code>rawEventData</code>, and values are the
	result of evaluating the corresponding <code>JsExp</code>.</dd>
	<dt><code>eventStream</code></dt>
	<dd>The <code>EventStream</code> that fires <code>DOMEvent</code>s.
	The data also exists in raw form in <code>rawEventStream</code></dd>
</dl>

<h3><code>DOMProperty</code></h3>
<p>Up until now we discussed the mechanism by which events get from
the browser to your code running on the server. In contrast, <code>DOMProperty</code>
wraps a <code>Var</code> which is used to keep state synchronized
between the browser and its representation in your Scala code. Here are
some of its members:</p>
<dl>
	<dt><code>value</code></dt>
	<dd>The most important member: this is the <code>Var</code> that
	we mentioned. Setting its value will result in the corresponding
	property being changed in the browser on whichever <code>Page</code>s
	are registered with this <code>DOMProperty</code> (whether via Ajax or
	Comet) except for the <code>Page</code> that is currently firing an
	Ajax event that is setting its value, if any.</dd>
	<dt><code>updateOn</code></dt>
	<dd>Calling this method with a <code>DOMEventSource</code> will
	add an element to its <code>rawEventData</code> with a JavaScript
	expression that reads the value of this property. When <code>Page</code>s
	are added subsequently, the value of the property will be updated via
	the <code>rawEventStream</code>.</dd>
</dl>

<h3><code>RElem</code></h3>
<p>In a sense, <code>RElem</code> is the glue that holds the above
traits together. It contains a base <code>scala.xml.Elem</code>, a
unique id, a set of <code>DOMEventSource</code>s and <code>DOMProperty</code>s,
and a set of <code>Page</code>s it has been rendered to. When you call <code>render</code>
on an <code>RElem</code>, it finds the current <code>Page</code> via the
implicits scope (if you don't pass one in explicitly), records it, and
adds it to all <code>DOMProperty</code>s. Then, a <code>scala.xml.Elem</code>
is returned, which is generated by starting with <code>baseElem</code>,
adding the id attribute, adding attributes that correspond to the
current values of the properties, and adding event handler attributes
for those <code>DOMEventSource</code>s to which listeners have been
added.</p>
<p><code>RElem</code> extends <code>net.liftweb.util.Bindable</code>,
so you can use instances directly in bind expressions (both using <code>Helpers.bind</code>,
and using CSS Selector binding), without calling <code>render</code>.
Lift will call the <code>asHtml</code> method, which calls <code>render</code>
with the <code>Page</code> that is in the <code>CurrentPage</code> <code>RequestVar</code>
(you don't have to set it; the first time in a request its value is
read, a new <code>Page</code> will be created, which will be kept for
the rest of the request).</p>
<p>There are a number of ways to get <code>RElem</code> instances.
Of course, you can extend it yourself. There are many traits, classes,
and factories for HTML elements, such as form elements. There's a
general-purpose factory, <code>RElem.apply(parentElem:
scala.xml.Elem, children: RElem*)</code>, which wraps a regular <code>scala.xml.Elem</code>
(and optionally some <code>RElems</code> to put inside), and its
overload, <code>RElem.apply(text: String)</code>, which returns an <code>RElem</code>
that wraps a &lt;span&gt; containing the text. And there's <code>Cell</code>
and <code>Repeater</code>.</p>

<h3><code>Cell</code></h3>
<p><code>Cell</code> is a trait that extends <code>RElem</code>. It
is used to manage an <code>RElem</code> whose contents &mdash; its child
elements &mdash; are represented by a <code>Signal[NodeSeq]</code>. It
is available through implementations that extend it. But it also has a
factory that can be used in CSS selector binding, to make the contents
of any element &mdash; even one defined in a template &mdash; dynamic.</p>
<h4>Template:</h4>
<pre class="brush: xml">
&lt;span id="cell"&gt;
  &lt;span id="time"/&gt;
  second(s) have elapsed.
&lt;/span&gt;
</pre>
<h4>Snippet:</h4>
<pre class="brush: scala">
class ElapsedSeconds extends ReactiveSnippet {
  // Display the number of elapsed seconds
  val signal =
    Timer(1000).hold(0).map(n =&gt; (n/1000).toString)

  def render =
    "#cell" #&gt; Cell {
      signal map {s =&gt;
        "#time" #&gt; s
      }
    }
}  
</pre>
<p>This factory actually takes and returns a <code>NodeSeq=&gt;NodeSeq</code>.
When the returned function is called, it instantiates an <code>RElem</code>,
using the (template) <code>NodeSeq</code> passed to it as the outer
element. Its children are generated by running the binding function
passed in on the children of the template element.</p>

<h3><code>Repeater</code></h3>
<p><code>Repeater</code> is the <code>SeqSignal</code> counterpart
of <code>Cell</code>. Where <code>Cell</code> defines its entire
contents using a <code>Signal</code> &mdash; whenever the <code>Signal</code>'s
value changes, the entire contents of the element have to be replaced
&mdash; <code>Repeater</code> uses a <code>SeqSignal[NodeSeq]</code>.
This is a very powerful feature. It means you can represent a dynamic
set of items, completely declaratively, and (without you worrying about
the details) when items change, only what needs updating will be
updated.</p>
<p>Besides for implementations such as <code>Select</code> (for HTML
select elements), <code>Repeater</code> has a factory similar to <code>Cell</code>'s.</p>



<h4>Template:</h4>
<pre class="brush: xml">
&lt;table id="people"&gt;
  &lt;tr class="eachPerson"&gt;
    &lt;td class="last" /&gt;
    &lt;td class="first" /&gt;
  &lt;/tr&gt;
&lt;/table&gt;
</pre>
<h4>Snippet:</h4>
<pre class="brush: scala">
class People extends ReactiveSnippet {
  val signal = BufferSignal[Person]()

  def render =
    "#people" #&gt; Repeater { signal map {
      _ map {person =&gt;
        ".eachPerson" #&gt; {
          ".last" #&gt; person.last &amp;
          ".first" #&gt; person.first
        }
      }
    }}
}
</pre>
<p>Once again, you pass the factory a binding function to be run on
the children of the template element, and it returns a binding function
that lift runs against the template. When run, the function instantiates
an <code>RElem</code> that uses the element from the template as the
outer element, and the binding function you passed to the factory is run
on each element.</p>
</div>
